---
title: "Demo"
author: "Finnian Lattimore"
date: "09/09/2014"
output: html_document
---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r generate-data}
# generate some random data 
N = 100
x = rnorm(N)
x2 = rnorm(N,mean=1,sd=1.3)
x3 = rpois(N,lambda=1)
y = 5+2*x-.3*x2+x3+rnorm(sd=.2)
data = data.frame(x,x2,x3,y)
head(data) # view a the first rows of the data
summary(data) # view a short summary of the data


# write it out to a file
write.table(data,file="rdemo.csv")
rm(data) # delete data from memory
```



```{r regression}
data = read.table("rdemo.csv")

# split the data in half (I will use half to train the model and the other half to test it)
train_rows = sample(1:N,N/2)
train = data[train_rows,]
test = data[-train_rows,]

model1 = lm(y~.,data=train) # regress y against all covariates ie y = a + bx1+cx2+dx3
model2 = lm(y~x+x2+x3,data=train) # same as the above

model3 = lm(y~x+x2+x3+x*x2,data=train) # adds an interaction term between x and x2

summary(model1) #summarize coeficients and fit for model1
plot(model1) # do some plots of residuals etc for model1

test$p1 = predict(model1,newdata=test) #add a column p1 to test containing the predictions  made by model1
test$p2 = predict(model2,newdata=test) 
test$p3 = predict(model3,newdata=test)

rmse1 = sqrt(mean((test$p1-test$y)^2)) #caclualte the rmse between predictions generated by model1 and y on the test data
rmse2 = sqrt(mean((test$p2-test$y)^2))
rmse3 = sqrt(mean((test$p3-test$y)^2))

m = lm.fit(train[,c(1,2,3)],train[,4])
```

```{r loopy}
# I will build a series of regression models inside a loop, evaluate them on new data and save results into a new data.frame (ie table)


all <- expand.grid(p1 = c(T,F), p2 = c(T,F), p3 = c(T,F)) # generate all the permutations of variables we want to try in our model
all <- all[1:7,] # drop the last row as it represents a model with no variables
nrows = nrow(all)
result = data.frame(terms = rep(NA,nrows),rmse = rep(NA,nrows))
all_vars = c(1,2,3) # indexes of the variables in train

for (row in 1:nrows) {
  selected = unlist(all[row,])
  print(selected)
  vars = c(all_vars[selected],4)
  print(vars)
  d = train[,vars]
  print(ncol(d))
  model = lm(y~.,data=train[,vars])
  pred = predict(model,newdata=test)
  rmse = sqrt(mean((pred-test$y)^2))
  result[row,1] = toString(vars)
  result[row,2] = rmse
}

result[which.min(result$rmse),] # find the model with the lowest rmse.
```
